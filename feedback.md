## 解説
> ポイント
- ユーザー関数の引数に配列のポインタを使用する
- 売り買いの比較の方法

> ポインタとは？？配列との違い
- ポインタとはデータの入っているところを保存する変数
    - つまりのところデータの住所のことです
- 配列のポインタを引数として渡すのは配列のデータを変えられるようにするため
    - 配列を引数にするとそのコピーが別に作られるだけ、、
- コピーではなく保存してるアドレスを指定しないと、処理上は値変えた！と思っていても変更できてなかったり、変な値が入ったりするのでポインタは超大切！

> コードレビュー
- どこが違っていたのか？
buy,sell関数のif文の処理  
~~~C
for(i = 1;i < day-1;i++){
    if(kabuka[i + 1] < kabuka[i]){
        buy[i] = 1;
        buy[i + 1] = 0;
    }
}
~~~
デバッグすると0を入れたのに、次のループで1になって意味がない状態になってました。前日の株価が高いと次の日に買うというえげつない現象も発生してます。  
sellも同様なので省略します。  
正直問題のレベルがかなり高いですね。。。

> 正解(?笑)の解説
~~~c
for(nowaday = i;nowaday < day-1;nowaday++){
    if(max < stockPrice[nowaday]){
        max = stockPrice[nowaday];
    }
}
//一番高く売れるのが近い日を探す
for(nowaday = i;nowaday < day-1;nowaday++){
    if(max == stockPrice[nowaday]){
        myProfit += stockPrice[nowaday] - myStock;
        printf("sell : day %d at %d\n",nowaday,stockPrice[nowaday]);
        i = nowaday;//最大値の次の日から購入させる
        break;
    }
}
myStock = 0;//持株をなくす
~~~
一番初めのfor文は現在の日にち(nowaday)から後の日で一番高く売れる金額を探しています。  
次のfor文で一番高い売値が近い日を探しています。見つかると売りに出し、売った次の日から始められるようにiを上書きします(iが2日目の2で4日目に売りに出した場合5から始めるようにする感じです)  
強制的に残りのfor文の処理を抜けて持っている株を無くします。

> まとめ  <br>
分かりにくいとかもっと詳しくなどありましたら、遠慮なくDMでもなんでもしてくださいね〜
